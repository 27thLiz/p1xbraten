diff --git src/Makefile src/Makefile
index 2f748ec..d423f05 100644
--- src/Makefile
+++ src/Makefile
@@ -142,7 +142,8 @@ CLIENT_OBJS= \
 	fpsgame/weapon.o \
 	p1xbraten/servercommands.o \
 	p1xbraten/capability_probing.o \
-	p1xbraten/managed_games.o
+	p1xbraten/managed_games.o \
+	p1xbraten/namecomplete.o
 
 CLIENT_PCH= shared/cube.h.gch engine/engine.h.gch fpsgame/game.h.gch
 
diff --git src/engine/console.cpp src/engine/console.cpp
index 3664668..ffe61ef 100644
--- src/engine/console.cpp
+++ src/engine/console.cpp
@@ -9,7 +9,7 @@ reversequeue<cline, MAXCONLINES> conlines;
 int commandmillis = -1;
 string commandbuf;
 char *commandaction = NULL, *commandprompt = NULL;
-enum { CF_COMPLETE = 1<<0, CF_EXECUTE = 1<<1 };
+enum { CF_COMPLETE = 1<<0, CF_EXECUTE = 1<<1, CF_GAMECOMPLETE = 1<<2 };
 int commandflags = 0, commandpos = -1;
 
 VARFP(maxcon, 10, 200, MAXCONLINES, { while(conlines.length() > maxcon) delete[] conlines.pop().line; });
@@ -258,7 +258,7 @@ ICOMMAND(searchbinds,     "s", (char *action), searchbinds(action, keym::ACTION_
 ICOMMAND(searchspecbinds, "s", (char *action), searchbinds(action, keym::ACTION_SPECTATOR));
 ICOMMAND(searcheditbinds, "s", (char *action), searchbinds(action, keym::ACTION_EDITING));
 
-void inputcommand(char *init, char *action = NULL, char *prompt = NULL, char *flags = NULL) // turns input to the command line on or off
+void inputcommand(char *init, char *action = NULL, char *prompt = NULL, const char *flags = NULL) // turns input to the command line on or off
 {
     commandmillis = init ? totalmillis : -1;
     textinput(commandmillis >= 0, TI_CONSOLE);
@@ -273,13 +273,13 @@ void inputcommand(char *init, char *action = NULL, char *prompt = NULL, char *fl
     if(flags) while(*flags) switch(*flags++)
     {
         case 'c': commandflags |= CF_COMPLETE; break;
+        case 'g': commandflags |= CF_GAMECOMPLETE; break;
         case 'x': commandflags |= CF_EXECUTE; break;
-        case 's': commandflags |= CF_COMPLETE|CF_EXECUTE; break;
     }
-    else if(init) commandflags |= CF_COMPLETE|CF_EXECUTE;
+    if(init && init[0] == '/') commandflags |= CF_COMPLETE|CF_EXECUTE;
 }
 
-ICOMMAND(saycommand, "C", (char *init), inputcommand(init));
+ICOMMAND(saycommand, "C", (char *init), inputcommand(init, NULL, NULL, "g"));
 COMMAND(inputcommand, "ssss");
 
 void pasteconsole()
@@ -336,7 +336,7 @@ struct hline
 
     void run()
     {
-        if(flags&CF_EXECUTE && buf[0]=='/') execute(buf+1);
+        if(flags&CF_EXECUTE || buf[0]=='/') execute(buf[0]=='/' ? buf+1 : buf);
         else if(action)
         {
             alias("commandbuf", buf);
@@ -444,8 +444,10 @@ bool consolekey(int code, bool isdown)
 
     #ifdef __APPLE__
         #define MOD_KEYS (KMOD_LGUI|KMOD_RGUI)
+        #define SKIPWORD_KEYS (KMOD_LALT|KMOD_RALT)
     #else
         #define MOD_KEYS (KMOD_LCTRL|KMOD_RCTRL)
+        #define SKIPWORD_KEYS (KMOD_LCTRL|KMOD_RCTRL)
     #endif
 
     if(isdown)
@@ -468,7 +470,15 @@ bool consolekey(int code, bool isdown)
             {
                 int len = (int)strlen(commandbuf);
                 if(commandpos<0) break;
-                memmove(&commandbuf[commandpos], &commandbuf[commandpos+1], len - commandpos);
+                int end = commandpos+1;
+                if(SDL_GetModState()&SKIPWORD_KEYS)
+                {
+                    // extend range to the end of the next word
+                    const char *space = strchr(commandbuf+end, ' ');
+                    if(!space) end = len;
+                    else end = space-commandbuf+1;
+                }
+                memmove(&commandbuf[commandpos], &commandbuf[end], len - end + 1);
                 resetcomplete();
                 if(commandpos>=len-1) commandpos = -1;
                 break;
@@ -476,22 +486,50 @@ bool consolekey(int code, bool isdown)
 
             case SDLK_BACKSPACE:
             {
-                int len = (int)strlen(commandbuf), i = commandpos>=0 ? commandpos : len;
-                if(i<1) break;
-                memmove(&commandbuf[i-1], &commandbuf[i], len - i + 1);
+                int len = (int)strlen(commandbuf), end = commandpos>=0 ? commandpos : len;
+                if(end<1) break;
+                int start = end-1;
+                if(SDL_GetModState()&SKIPWORD_KEYS)
+                {
+                    int prevpos = start; char prevchar = commandbuf[start]; commandbuf[start] = 0; // temporarily shorten commandbuf to end-1
+                    // extend range to beginning of the previous word
+                    const char *space = strrchr(commandbuf, ' ');
+                    if(!space) start = 0;
+                    else start = space-commandbuf+1;
+                    commandbuf[prevpos] = prevchar;
+                }
+                memmove(&commandbuf[start], &commandbuf[end], len - end + 1);
                 resetcomplete();
-                if(commandpos>0) commandpos--;
+                if(commandpos>0) commandpos = start;
                 else if(!commandpos && len<=1) commandpos = -1;
                 break;
             }
 
             case SDLK_LEFT:
-                if(commandpos>0) commandpos--;
-                else if(commandpos<0) commandpos = (int)strlen(commandbuf)-1;
+                if(SDL_GetModState()&SKIPWORD_KEYS && commandpos!=0)
+                {
+                    int prevpos = 0; char prevchar = ' '; // temporarily shorten commandbuf to commandpos-1
+                    if(commandpos>0) { prevpos = commandpos-1; prevchar = commandbuf[prevpos]; commandbuf[prevpos] = 0; }
+                    const char *space = strrchr(commandbuf, ' ');
+                    if(!space) commandpos = 0;
+                    else commandpos = space-commandbuf+1;
+                    if(prevpos>0) commandbuf[prevpos] = prevchar;
+                }
+                else
+                {
+                    if(commandpos>0) commandpos--;
+                    else if(commandpos<0) commandpos = (int)strlen(commandbuf)-1;
+                }
                 break;
 
             case SDLK_RIGHT:
-                if(commandpos>=0 && ++commandpos>=(int)strlen(commandbuf)) commandpos = -1;
+                if(SDL_GetModState()&SKIPWORD_KEYS && commandpos>=0)
+                {
+                    const char *space = strchr(commandbuf+commandpos+1, ' ');
+                    if(!space) commandpos = -1;
+                    else commandpos = space-commandbuf;
+                }
+                else if(commandpos>=0 && ++commandpos>=(int)strlen(commandbuf)) commandpos = -1;
                 break;
 
             case SDLK_UP:
@@ -504,9 +542,15 @@ bool consolekey(int code, bool isdown)
                 break;
 
             case SDLK_TAB:
-                if(commandflags&CF_COMPLETE)
+                if(commandflags&CF_COMPLETE || (commandflags&CF_GAMECOMPLETE && commandbuf[0]=='/'))
+                {
+                    bool prefixslash = commandbuf[0]=='/' || (!commandaction && !(commandflags&CF_GAMECOMPLETE));
+                    complete(commandbuf, sizeof(commandbuf), prefixslash ? "/" : NULL);
+                    if(commandpos>=0 && commandpos>=(int)strlen(commandbuf)) commandpos = -1;
+                }
+                else if(commandflags&CF_GAMECOMPLETE)
                 {
-                    complete(commandbuf, sizeof(commandbuf), commandflags&CF_EXECUTE ? "/" : NULL);
+                    game::complete(commandbuf, sizeof(commandbuf));
                     if(commandpos>=0 && commandpos>=(int)strlen(commandbuf)) commandpos = -1;
                 }
                 break;
@@ -668,7 +712,7 @@ static hashtable<char *, filesval *> completions;
 int completesize = 0;
 char *lastcomplete = NULL;
 
-void resetcomplete() { completesize = 0; }
+void resetcomplete() { completesize = 0; game::resetcomplete(); }
 
 void addcomplete(char *command, int type, char *dir, char *ext)
 {
diff --git src/fpsgame/client.cpp src/fpsgame/client.cpp
index 1e3163e..af68b0c 100644
--- src/fpsgame/client.cpp
+++ src/fpsgame/client.cpp
@@ -1492,6 +1492,8 @@ namespace game
                     broadcastp1xbratenversion();
                 }
                 copystring(d->name, text, MAXNAMELEN+1);
+                filternonalphanum(text, text, MAXNAMELEN);
+                copystring(d->alphanumname, text, MAXNAMELEN);
                 getstring(text, p);
                 filtertext(d->team, text, false, false, MAXTEAMLEN);
                 d->playermodel = getint(p);
@@ -1508,6 +1510,8 @@ namespace game
                     {
                         if(!isignored(d->clientnum)) conoutf(CON_INFO + (d->state==CS_SPECTATOR ? CON_NONZEN : 0), "%s is now known as %s", colorname(d), colorname(d, text));
                         copystring(d->name, text, MAXNAMELEN+1);
+                        filternonalphanum(text, text, MAXNAMELEN);
+                        copystring(d->alphanumname, text, MAXNAMELEN);
                     }
                 }
                 break;
diff --git src/fpsgame/game.h src/fpsgame/game.h
index 843dc15..49ad01b 100644
--- src/fpsgame/game.h
+++ src/fpsgame/game.h
@@ -563,6 +563,7 @@ struct fpsent : dynent, fpsstate
     int smoothmillis;
 
     string name, team, info;
+    string alphanumname;
     int playermodel;
     ai::aiinfo *ai;
     int ownernum, lastnode;
@@ -572,7 +573,7 @@ struct fpsent : dynent, fpsstate
 
     fpsent() : weight(100), clientnum(-1), privilege(PRIV_NONE), lastupdate(0), plag(0), ping(0), lifesequence(0), respawned(-1), suicided(-1), lastpain(0), attacksound(-1), attackchan(-1), idlesound(-1), idlechan(-1), frags(0), flags(0), deaths(0), totaldamage(0), totalshots(0), suicides(0), edit(NULL), smoothmillis(-1), playermodel(-1), ai(NULL), ownernum(-1), p1xbratenversion(0, 0, 0), muzzle(-1, -1, -1)
     {
-        name[0] = team[0] = info[0] = 0;
+        name[0] = team[0] = info[0] = alphanumname[0] = 0;
         respawn();
     }
     ~fpsent()
@@ -780,6 +781,7 @@ namespace game
     extern void sendposition(fpsent *d, bool reliable = false);
     extern void broadcastp1xbratenversion();
     extern bool setp1xbratenversion(fpsent *d, int version);
+    extern void filternonalphanum(char *dst, const char *src, size_t len);
 
     // monster
     struct monster;
diff --git src/p1xbraten/namecomplete.cpp src/p1xbraten/namecomplete.cpp
new file mode 100644
index 0000000..90dc855
--- /dev/null
+++ src/p1xbraten/namecomplete.cpp
@@ -0,0 +1,56 @@
+#include "game.h"
+
+namespace game
+{
+    int completesize = 0;
+    char *lastcompletealphanum = NULL;
+
+    void complete(char *s, int maxlen) // completes client names
+    {
+        char *word = strrchr(s, ' ');
+        if(!word) word = s;
+        else word++;
+    
+        static string alphanumword = "";
+        filternonalphanum(alphanumword, word, maxlen); // make word in console comparable
+
+        if(!completesize) { completesize = (int)strlen(word); DELETEA(lastcompletealphanum); }
+
+        const char *nextcomplete = NULL, *nextcompletealphanum = NULL;
+        loopv(clients)
+        {
+            fpsent *ci = clients[i];
+            if(!ci) continue;
+            if(strncasecmp(ci->alphanumname, alphanumword, completesize)==0 &&
+               (!lastcompletealphanum || strcasecmp(ci->alphanumname, lastcompletealphanum) > 0) && (!nextcompletealphanum || strcasecmp(ci->alphanumname, nextcompletealphanum) < 0))
+            {
+                nextcompletealphanum = ci->alphanumname;
+                nextcomplete = ci->name;
+            }
+        }
+        DELETEA(lastcompletealphanum);
+        if(nextcomplete)
+        {
+            copystring(word, nextcomplete, maxlen);
+            lastcompletealphanum = newstring(nextcompletealphanum);
+        }
+    }
+
+    void resetcomplete() { completesize = 0; }
+
+    void filternonalphanum(char *dst, const char *src, size_t len)
+    {
+        for(int c = uchar(*src); c; c = uchar(*++src))
+        {
+            if(c == '\f')
+            {
+                if(!*++src) break;
+                continue;
+            }
+            if(!iscubealnum(c)) continue;
+            *dst++ = c;
+            if(!--len) break;
+        }
+        *dst = '\0';
+    }
+}
\ No newline at end of file
diff --git src/shared/igame.h src/shared/igame.h
index 1c532c1..37a3537 100644
--- src/shared/igame.h
+++ src/shared/igame.h
@@ -50,6 +50,8 @@ namespace game
     extern const char *savedservers();
     extern void loadconfigs();
     extern int writeembeddedcfgs();
+    extern void complete(char *s, int maxlen);
+    extern void resetcomplete();
 
     extern void updateworld();
     extern void initclient();
diff --git src/vcpp/sauerbraten.vcxproj src/vcpp/sauerbraten.vcxproj
index 7d46df0..b18b8dd 100644
--- src/vcpp/sauerbraten.vcxproj
+++ src/vcpp/sauerbraten.vcxproj
@@ -1309,6 +1309,20 @@
       <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)game.pch</PrecompiledHeaderOutputFile>
       <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)game.pch</PrecompiledHeaderOutputFile>
     </ClCompile>
+    <ClCompile Include="..\p1xbraten\namecomplete.cpp">
+      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">game.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">game.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)game.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)game.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Profile|Win32'">game.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Profile|x64'">game.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Profile|Win32'">$(IntDir)game.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Profile|x64'">$(IntDir)game.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">game.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">game.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)game.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)game.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="..\fpsgame\weapon.cpp">
       <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">game.h</PrecompiledHeaderFile>
       <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">game.h</PrecompiledHeaderFile>
