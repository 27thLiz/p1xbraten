Index: src/Makefile
===================================================================
--- src/Makefile	(revision 6295)
+++ src/Makefile	(working copy)
@@ -130,6 +130,7 @@
 	fpsgame/render.o \
 	fpsgame/scoreboard.o \
 	fpsgame/server.o \
+	fpsgame/weaponstats.o \
 	fpsgame/waypoint.o \
 	fpsgame/weapon.o

@@ -468,6 +469,7 @@
 fpsgame/client.o: shared/ents.h shared/command.h shared/glexts.h
 fpsgame/client.o: shared/glemu.h shared/iengine.h shared/igame.h fpsgame/ai.h
 fpsgame/client.o: fpsgame/capture.h fpsgame/ctf.h fpsgame/collect.h
+fpsgame/client.o: fpsgame/weaponstats.h
 fpsgame/entities.o: fpsgame/game.h shared/cube.h shared/tools.h shared/geom.h
 fpsgame/entities.o: shared/ents.h shared/command.h shared/glexts.h
 fpsgame/entities.o: shared/glemu.h shared/iengine.h shared/igame.h
@@ -475,6 +477,7 @@
 fpsgame/fps.o: fpsgame/game.h shared/cube.h shared/tools.h shared/geom.h
 fpsgame/fps.o: shared/ents.h shared/command.h shared/glexts.h shared/glemu.h
 fpsgame/fps.o: shared/iengine.h shared/igame.h fpsgame/ai.h
+fpsgame/fps.o: fpsgame/weaponstats.h
 fpsgame/monster.o: fpsgame/game.h shared/cube.h shared/tools.h shared/geom.h
 fpsgame/monster.o: shared/ents.h shared/command.h shared/glexts.h
 fpsgame/monster.o: shared/glemu.h shared/iengine.h shared/igame.h
@@ -502,6 +505,8 @@
 fpsgame/weapon.o: fpsgame/game.h shared/cube.h shared/tools.h shared/geom.h
 fpsgame/weapon.o: shared/ents.h shared/command.h shared/glexts.h
 fpsgame/weapon.o: shared/glemu.h shared/iengine.h shared/igame.h fpsgame/ai.h
+fpsgame/weapon.o: fpsgame/weaponstats.h
+fpsgame/weaponstats.o: fpsgame/game.h

 shared/cube.h.gch: shared/tools.h shared/geom.h shared/ents.h
 shared/cube.h.gch: shared/command.h shared/glexts.h shared/glemu.h
@@ -514,6 +519,7 @@
 fpsgame/game.h.gch: shared/cube.h shared/tools.h shared/geom.h shared/ents.h
 fpsgame/game.h.gch: shared/command.h shared/glexts.h shared/glemu.h
 fpsgame/game.h.gch: shared/iengine.h shared/igame.h fpsgame/ai.h
+fpsgame/game.h.gch: fpsgame/weaponstats_type.h fpsgame/weaponstats.h

 shared/crypto-standalone.o: shared/cube.h shared/tools.h shared/geom.h
 shared/crypto-standalone.o: shared/ents.h shared/command.h shared/iengine.h
Index: src/fpsgame/client.cpp
===================================================================
--- src/fpsgame/client.cpp	(revision 6295)
+++ src/fpsgame/client.cpp	(working copy)
@@ -1,4 +1,5 @@
 #include "game.h"
+#include "weaponstats.h"

 namespace game
 {
@@ -1501,6 +1502,7 @@
                 s->lastaction = lastmillis;
                 s->lastattackgun = s->gunselect;
                 shoteffects(s->gunselect, from, to, s, false, id, prevaction);
+                recordshot(s);
                 break;
             }

Index: src/fpsgame/fps.cpp
===================================================================
--- src/fpsgame/fps.cpp	(revision 6295)
+++ src/fpsgame/fps.cpp	(working copy)
@@ -1,4 +1,5 @@
 #include "game.h"
+#include "weaponstats.h"

 namespace game
 {
@@ -396,6 +397,8 @@
     {
         if((d->state!=CS_ALIVE && d->state != CS_LAGGED && d->state != CS_SPAWNING) || intermission) return;

+        recordhit(actor, d, damage);
+
         if(local) damage = d->dodamage(damage);
         else if(actor==player1) return;

@@ -530,9 +533,8 @@
     ICOMMAND(getfrags, "", (), intret(player1->frags));
     ICOMMAND(getflags, "", (), intret(player1->flags));
     ICOMMAND(getdeaths, "", (), intret(player1->deaths));
-    ICOMMAND(getaccuracy, "", (), intret((player1->totaldamage*100)/max(player1->totalshots, 1)));
-    ICOMMAND(gettotaldamage, "", (), intret(player1->totaldamage));
-    ICOMMAND(gettotalshots, "", (), intret(player1->totalshots));
+    ICOMMAND(gettotaldamage, "", (), intret(damage(player1, DMG_DEALT)));
+    ICOMMAND(gettotalshots, "", (), intret(damage(player1, DMG_POTENTIAL)));

     vector<fpsent *> clients;

@@ -620,6 +622,7 @@
             d->maxhealth = 100;
             d->lifesequence = -1;
             d->respawned = d->suicided = -2;
+            d->stats.reset();
         }

         setclientmode();
Index: src/fpsgame/game.h
===================================================================
--- src/fpsgame/game.h	(revision 6295)
+++ src/fpsgame/game.h	(working copy)
@@ -535,6 +535,8 @@
     }
 };

+#include "weaponstats_type.h"
+
 struct fpsent : dynent, fpsstate
 {
     int weight;                         // affects the effectiveness of hitpush
@@ -549,6 +551,7 @@
     int lastpickup, lastpickupmillis, lastbase, lastrepammo, flagpickup, tokens;
     vec lastcollect;
     int frags, flags, deaths, totaldamage, totalshots;
+    weaponstats stats;
     editinfo *edit;
     float deltayaw, deltapitch, deltaroll, newyaw, newpitch, newroll;
     int smoothmillis;
@@ -846,6 +849,8 @@
     extern vec hudgunorigin(int gun, const vec &from, const vec &to, fpsent *d);
 }

+#include "weaponstats.h"
+
 namespace server
 {
     extern const char *modename(int n, const char *unknown = "unknown");
Index: src/fpsgame/weapon.cpp
===================================================================
--- src/fpsgame/weapon.cpp	(revision 6295)
+++ src/fpsgame/weapon.cpp	(working copy)
@@ -1,5 +1,6 @@
 // weapon.cpp: all shooting and effects code, projectile management
 #include "game.h"
+#include "weaponstats.h"

 namespace game
 {
@@ -825,6 +826,7 @@
 		d->gunwait = guns[d->gunselect].attackdelay;
 		if(d->gunselect == GUN_PISTOL && d->ai) d->gunwait += int(d->gunwait*(((101-d->skill)+rnd(111-d->skill))/100.f));
         d->totalshots += guns[d->gunselect].damage*(d->quadmillis ? 4 : 1)*guns[d->gunselect].rays;
+        recordshot(d);
     }

     void adddynlights()
Index: src/fpsgame/weaponstats.cpp
===================================================================
--- src/fpsgame/weaponstats.cpp	(nonexistent)
+++ src/fpsgame/weaponstats.cpp	(working copy)
@@ -0,0 +1,65 @@
+#include "game.h"
+
+namespace game {
+    void recordshot(fpsent *shooter)
+    {
+        if(!shooter) return;
+        int gun = shooter->gunselect;
+        int potentialdamage = guns[gun].damage * (shooter->quadmillis ? 4 : 1 ) * guns[gun].rays;
+        shooter->stats.add(DMG_POTENTIAL, gun, potentialdamage);
+    }
+
+    bool shouldcounthit(fpsent *attacker, fpsent *target)
+    {
+        return (attacker != target) && !isteam(attacker->team, target->team);
+    }
+
+    void recordhit(fpsent *attacker, fpsent *target, int damage)
+    {
+        if(!shouldcounthit(attacker, target)) return;
+        int gun = attacker->gunselect;
+        // try to fix gun used to deal the damage
+        if(gun == GUN_RL || gun == GUN_GL || damage != guns[gun].damage * (attacker->quadmillis ? 4 : 1))
+        {
+            gun = attacker->stats.lastprojectile;
+        }
+        attacker->stats.add(DMG_DEALT, gun, damage);
+        target->stats.add(DMG_RECEIVED, gun, damage);
+    }
+
+    #define DMG_ICOMMAND(name,ret) ICOMMAND(name, "V", (tagval *args, int numargs), { \
+        int gun = numargs > 0 ? args[0].getint() : -1; \
+        fpsent *p = numargs > 1 ? getclient(args[1].getint()) : hudplayer(); \
+        return ret;\
+    })
+
+    int damage(fpsent *p, int typ, int gun)
+    {
+        if(!p) p = hudplayer();
+        return p->stats.get(typ, gun);
+    }
+    DMG_ICOMMAND(getdamagepotential, intret(damage(p, DMG_POTENTIAL, gun)))
+    DMG_ICOMMAND(getdamagedealt, intret(damage(p, DMG_DEALT, gun)))
+    DMG_ICOMMAND(getdamagereceived, intret(damage(p, DMG_RECEIVED, gun)))
+
+    int damagewasted(fpsent *p, int gun)
+    {
+        if(!p) p = hudplayer();
+        return p->stats.wasted(gun);
+    }
+    DMG_ICOMMAND(getdamagewasted, intret(damagewasted(p, gun)))
+
+    int netdamage(fpsent *p, int gun)
+    {
+        if(!p) p = hudplayer();
+        return p->stats.net(gun);
+    }
+    DMG_ICOMMAND(getnetdamage, intret(netdamage(p, gun)))
+
+    float accuracy(fpsent *p, int gun)
+    {
+        if(!p) p = hudplayer();
+        return p->stats.accuracy(gun);
+    }
+    DMG_ICOMMAND(getaccuracy, floatret(accuracy(p, gun)))
+}
Index: src/fpsgame/weaponstats.h
===================================================================
--- src/fpsgame/weaponstats.h	(nonexistent)
+++ src/fpsgame/weaponstats.h	(working copy)
@@ -0,0 +1,14 @@
+#ifndef __WEAPONSTATS_H__
+#define __WEAPONSTATS_H__
+
+namespace game {
+    extern void recordshot(fpsent *shooter);
+    extern bool shouldcounthit(fpsent *attacker, fpsent *target);
+    extern void recordhit(fpsent *attacker, fpsent *target, int damage);
+    extern int damage(fpsent *p, int typ, int gun = -1);
+    extern int damagewasted(fpsent *p, int gun = -1);
+    extern int netdamage(fpsent *p, int gun = -1);
+    extern float accuracy(fpsent *p, int gun = -1);
+}
+
+#endif
Index: src/fpsgame/weaponstats_type.h
===================================================================
--- src/fpsgame/weaponstats_type.h	(nonexistent)
+++ src/fpsgame/weaponstats_type.h	(working copy)
@@ -0,0 +1,59 @@
+#ifndef __WEAPONSTATS_TYPE_H__
+#define __WEAPONSTATS_TYPE_H__
+
+#define NUM_MP_GUNS (GUN_PISTOL+1 - GUN_FIST)
+#define guninrange(i) (i >= 0 && i < NUM_MP_GUNS)
+
+enum { DMG_POTENTIAL = 0, DMG_DEALT, DMG_RECEIVED, NUM_DMG_TYPES };
+#define dmgtypeinrange(i) (i >= 0 && i < NUM_DMG_TYPES)
+
+struct weaponstats {
+    int lastprojectile;
+
+    int damage[NUM_DMG_TYPES][NUM_MP_GUNS];
+
+    weaponstats()
+    {
+        reset();
+    }
+
+    void reset()
+    {
+        lastprojectile = -1;
+        loopi(NUM_DMG_TYPES) loopj(NUM_MP_GUNS) damage[i][j] = 0;
+    }
+
+    void add(int typ, int gun, int dmg)
+    {
+        if(!dmgtypeinrange(typ) || !guninrange(gun)) return;
+        damage[typ][gun] += dmg;
+        if(typ == DMG_POTENTIAL && (gun == GUN_RL || gun == GUN_GL)) lastprojectile = gun;
+    }
+
+    int get(int typ, int gun)
+    {
+        if(!dmgtypeinrange(typ)) return 0;
+        if(guninrange(gun)) return damage[typ][gun];
+        int total = 0;
+        loopi(NUM_MP_GUNS) total += damage[typ][i];
+        return total;
+    }
+
+    int wasted(int gun)
+    {
+        return get(DMG_POTENTIAL, gun) - get(DMG_DEALT, gun);
+    }
+
+    int net(int gun)
+    {
+        return get(DMG_DEALT, gun) - get(DMG_RECEIVED, gun);
+    }
+
+    float accuracy(int gun)
+    {
+        float nonzerototal = max(1.0f, (float)get(DMG_POTENTIAL, gun));
+        return min(100.0f, (float)get(DMG_DEALT, gun) / nonzerototal * 100.0f);
+    }
+};
+
+#endif
Index: src/fpsgame/scoreboard.cpp
===================================================================
--- src/fpsgame/scoreboard.cpp	(revision 6295)
+++ src/fpsgame/scoreboard.cpp	(working copy)
@@ -14,6 +14,9 @@
     VARP(showconnecting, 0, 0, 1);
     VARP(hidefrags, 0, 1, 1);
     VARP(showdeaths, 0, 0, 1);
+    VARP(showkpd, 0, 0, 1);
+    VARP(showaccuracy, 0, 0, 1);
+    VARP(showdamage, 0, 0, 2);

     static hashset<teaminfo> teaminfos;

@@ -258,6 +261,38 @@
                 g.poplist();
             }

+            if(showkpd)
+            {
+                g.pushlist();
+                g.strut(5);
+                g.text("kpd", fgcolor);
+                loopscoregroup(o, g.textf("%.1f", 0xFFFFDD, NULL, (float)o->frags/max(1, o->deaths)));
+                g.poplist();
+            }
+
+            if(showaccuracy)
+            {
+                g.pushlist();
+                g.strut(5);
+                g.text("acc", fgcolor);
+                loopscoregroup(o, g.textf("%.0f%%", 0xFFFFDD, NULL, accuracy(o)));
+                g.poplist();
+            }
+
+            if(showdamage)
+            {
+                g.pushlist();
+                g.strut(6);
+                g.text("dd", fgcolor);
+                loopscoregroup(o, {
+                    float dmg = (float) showdamage == 1 ? damage(o, DMG_DEALT) : netdamage(o);
+                    const char *fmt = "%.0f";
+                    if(abs(dmg) > 1000.0f) { fmt = "%.1fk"; dmg = dmg/1000.0f; }
+                    g.textf(fmt, 0xFFFFDD, NULL, dmg);
+                });
+                g.poplist();
+            }
+
             g.pushlist();
             g.text("name", fgcolor);
             g.strut(12);
